## Problem:
You are given a string  `s`  consisting of the characters  `'a'`,  `'b'`, and  `'c'`  and a non-negative integer  `k`. Each minute, you may take either the  **leftmost**  character of  `s`, or the  **rightmost**  character of  `s`.

Return _the  **minimum**  number of minutes needed for you to take  **at least**_ `k` _of each character, or return_ `-1` _if it is not possible to take_ `k` _of each character._

### Thoughts:
This is obviously a two pointer problem since we need to take an arbitrary number 'k' total characters from a string while working from the left and right side of the string. That is, if we have characters a, b, and c within a string, we must have k total of each character. This will be one of my only solutions written in python. I'll be focusing on solutions 3 and 4.

### Solution 3 (Failed) [Wrong Answer]:
I imported a counter and call it letter_map that'll count each unique character within the string. Since the only characters we'd get is a, b, or c, we can check if the count of each character is less than k, if so, return -1. We initialize an empty dictionary called counter, left pointing to the first element in the string, right pointing to the last element in the string, and minutes and increment both set to 0. I do a ranged for loop that goes from n = 1 to the half length of the string plus 1. If the left pointer isn't in the counter, put that character into the counter and initialize it to one, else increment the counter and the minutes. Do the same with the right pointer. Move the left pointer to the right by 0 + increment and right pointer to the left by -1 - increment. I check if the individual characters are in the counter and then check if they are greater than or equal to k. If so, return the minutes, else, continue looping. This solution failed due to failing to handle special edge cases. This runs at an O(n) time complexity due to looping through the string.

### Solution 4 (Passed) [205ms runtime]:
This solution is more true to the sliding window solution required. I do away with the left, right, counter, and increment. Minutes is relabeled as window_length to better reflect the solution. The difference between this solution and Solution 3 starts at the purging of the unnecessary variables. The variables window_length and start are initialized to 0. I loop through the string with index and char storing the index and the character within the string respectively. I subtract 1 from the counter, matching with the char, this means that this character is outside the window frame. A while loop starts if the `letter_map[char]` is less than k, meaning we need to increment the character's counter and start until the counter is equal to k. This moves the window forward while restoring the character's count at `start` while `start` is the beginning of the window frame. Afterward, I take the max of window_length and `index - start + 1`. We do this for each character in the string. Once completed, return the difference of the length of the string and window_length. The length of the window frame is the largest valid substring. This better solution runs at O(n) time complexity since I loop through the string.
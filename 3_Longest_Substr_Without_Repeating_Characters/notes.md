## Problem:
Given a string `s`, find the length of the **longest** **substring** without repeating characters.

### Thoughts:
After reading the hints, a two pointer, or sliding window, solution as needed. However, it was not obvious at first, as the hint says to generate all possible substrings first, but that is a brute force solution. I have many solutions, but I'll stick with solutions 5, 9, and 10 since they're the ones with the most important information. 5 includes the brute force with wrong answer, 9 includes brute force with correct answers but time limit exceeded, and 10 is the fastest, corrected, and implemented differently.

### Solution 5: (Failed) [Wrong Answer]
Solution 5 is the first attempt but edited. We check if the string is empty, if so, return 0. I create a vector of strings and an integer tracking the max length of the substring. I have two pointers, one at the first element called len and one at the second element called pos being tracked by two for loops, or the previous and current pointers. We grab the substring from the string passed by passing pos and len as the first and second argument of the substring method respectively. If the substring's length is less than max length, continue. Check if the substring is unique with the is_unique method I wrote. Put the substring at the end of the vector of strings, set max_len to the size of the substring. After iterating completely, return the max_len.

### Solution 9: (Failed) [Time Limit Exceeded]
After fixing the wrong answers in solution 6, solution 9 is the final edition of the correct-answer-time-limit-exceeded era. It is basically solution 5, but optimized to run faster. I do away with the vector of strings since it isn't needed. The main difference now within the lengthOfLargestSubstring method is using std::max after checking if the substring is unique is true. The loop that deals with pos runs one less times than it used to. The biggest change was to the is_unique method, instead of using the previous-current pointer method, I use an unordered map of unique characters found within the substring. This reduces the loops to one loop.

### Solution 10: (Passed) [20ms runtime]
This solution combines the operations within is_unique method with logically better use of max_len and an integer called start. Both max_len and start are initialized to 0 and an unordered map called char_set is created. We iterate through the string passed in with a for loop with 'end' as the conditional variable. A while loop within the for loop is needed to check if the current character pointed to by end is within the map, if so, we'll erase where start is pointing to and increment start. Once we're done, or never hit the while loop at all, we'll insert the character into the char_set map and set max_len = std::max(max_len, end - start + 1). This is the sliding window technique, where the frame's length is dynamically changed based on conditions met. In our case, we move the left pointer (start) to the right if an ordinary character is found. The variable end is moved to the right on each iteration of the for loop.